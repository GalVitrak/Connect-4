/**
 * Connect-4 Game - AI Module
 * Implements multiple AI difficulty levels
 * 
 * Easy:   Random valid moves
 * Medium: Win/block detection + strategic positioning
 * Hard:   Minimax algorithm with alpha-beta pruning
 */

#include "ai.h"
#include "board.h"
#include "input.h"
#include "game.h"
#include <stdlib.h>
#include <time.h>
#include <limits.h>

/**
 * Find a winning move for the specified player
 * Simulates placing a piece in each column and checks if it wins
 * 
 * Parameters:
 *   player - Which player to find winning move for
 * 
 * Returns: GameMove with row/col if winning move found, {-1,-1} otherwise
 */
GameMove find_winning_move(Cell player) {
	/* Try each column */
	for (int col = 0; col < COLS; col++) {
		/* Find the lowest empty row in this column */
		for (int row = ROWS - 1; row >= 0; row--) {
			if (board[row][col] == cell_empty) {
				/* Simulate placing the piece */
				board[row][col] = player;
				GameMove test_move = { row, col };

				/* Check if this move wins */
				if (check_winner(test_move, player) == 1) {
					board[row][col] = cell_empty; /* Undo simulation */
					return test_move; /* Return winning move */
				}

				board[row][col] = cell_empty; /* Undo simulation */
				break; /* Only check lowest position in column */
			}
		}
	}

	/* No winning move found */
	GameMove no_move = { -1, -1 };
	return no_move;
}

/**
 * Count potential threats (2 or 3 in a row) for a given move
 * Used by medium AI to evaluate strategic positions
 * 
 * Parameters:
 *   row, col - Position to evaluate
 *   player   - Which player to evaluate for
 * 
 * Returns: Threat score (higher is better)
 */
int count_threats(int row, int col, Cell player) {
	int threats = 0;
	
	/* Temporarily place piece to test */
	board[row][col] = player;
	
	/* Check horizontal connections */
	int count = 1;
	int temp_col = col;
	/* Count right */
	while (temp_col + 1 < COLS && board[row][temp_col + 1] == player) {
		count++;
		temp_col++;
	}
	/* Count left */
	temp_col = col;
	while (temp_col - 1 >= 0 && board[row][temp_col - 1] == player) {
		count++;
		temp_col--;
	}
	if (count >= 2) threats += count; /* Award points for connections */
	
	/* Check vertical connections */
	count = 1;
	int temp_row = row;
	/* Count down */
	while (temp_row + 1 < ROWS && board[temp_row + 1][col] == player) {
		count++;
		temp_row++;
	}
	/* Count up */
	temp_row = row;
	while (temp_row - 1 >= 0 && board[temp_row - 1][col] == player) {
		count++;
		temp_row--;
	}
	if (count >= 2) threats += count;
	
	board[row][col] = cell_empty; /* Undo test */
	
	return threats;
}

/**
 * Find the best strategic move based on threat analysis
 * Considers piece connections and center column control
 * 
 * Returns: Best move found, or {-1,-1} if none
 */
GameMove find_best_strategic_move(Cell player) {
	int best_score = -1;
	GameMove best_move = {-1, -1};
	
	/* Evaluate each possible move */
	for (int col = 0; col < COLS; col++) {
		for (int row = ROWS - 1; row >= 0; row--) {
			if (board[row][col] == cell_empty) {
				int score = count_threats(row, col, player);
				
				/* Bonus points for center columns (more winning opportunities) */
				if (col == 3) score += 3;      /* Center column */
				else if (col == 2 || col == 4) score += 2; /* Near center */
				else if (col == 1 || col == 5) score += 1; /* Somewhat central */
				
				if (score > best_score) {
					best_score = score;
					best_move.row = row;
					best_move.column = col;
				}
				break; /* Only check lowest position */
			}
		}
	}
	
	return best_move;
}

/**
 * AI Easy difficulty - Random move selection
 * Picks a random valid column
 * 
 * Returns: Valid random move
 */
GameMove ai_easy_move(void) {
	int column = rand() % 7;
	
	/* Find lowest empty row in chosen column */
	int i;
	int full = 1;
	int row;
	for (i = 5; i >= 0; i--) {
		if (board[i][column] == cell_empty) {
			full = 0;
			row = i;
			break;
		}
	}
	
	/* If column full, try again recursively */
	if (full) {
		return ai_easy_move();
	}
	else {
		GameMove move = { row, column };
		return move;
	}
}

/**
 * AI Medium difficulty - Strategic play
 * Priority: Win > Block opponent > Strategic position > Center preference
 * Includes 30% randomness for unpredictability
 * 
 * Returns: Selected move
 */
GameMove ai_medium_move(void) {
	/* Initialize random seed once */
	static int seeded = 0;
	if (!seeded) {
		srand((unsigned int)time(NULL));
		seeded = 1;
	}
	
	/* Priority 1: Take winning move if available */
	GameMove winning_move = find_winning_move(cell_player2);
	if (winning_move.row != -1) {
		return winning_move;
	}

	/* Priority 2: Block opponent's winning move */
	GameMove blocking_move = find_winning_move(cell_player1);
	if (blocking_move.row != -1) {
		return blocking_move;
	}

	/* Priority 3: Make strategic move (70% of the time) */
	GameMove strategic_move = find_best_strategic_move(cell_player2);
	if (strategic_move.row != -1) {
		if (rand() % 100 < 70) { /* 70% chance to take strategic move */
			return strategic_move;
		}
	}

	/* Priority 4: Random center-biased move (for variety) */
	int center_preference[] = {3, 2, 4, 1, 5, 0, 6};
	
	/* Shuffle for randomness */
	for (int i = 0; i < 7; i++) {
		int j = rand() % 7;
		int temp = center_preference[i];
		center_preference[i] = center_preference[j];
		center_preference[j] = temp;
	}
	
	/* Find first valid column from shuffled list */
	for (int i = 0; i < 7; i++) {
		int col = center_preference[i];
		for (int row = ROWS - 1; row >= 0; row--) {
			if (board[row][col] == cell_empty) {
				GameMove move = { row, col };
				return move;
			}
		}
	}

	/* Fallback (shouldn't reach here) */
	return ai_easy_move();
}

/* ==================== HARD AI - MINIMAX ALGORITHM ==================== */

/**
 * Evaluate the board position for a given player
 * Scores based on potential 4-in-a-row patterns
 * 
 * Parameters:
 *   player - Player to evaluate position for
 * 
 * Returns: Position score (positive = good for player, negative = bad)
 */
int evaluate_position(Cell player) {
	int score = 0;
	Cell opponent = (player == cell_player1) ? cell_player2 : cell_player1;
	
	/* Scan all possible 4-cell windows and score them */
	
	/* Horizontal windows */
	for (int r = 0; r < ROWS; r++) {
		for (int c = 0; c <= COLS - 4; c++) {
			int player_count = 0;
			int opponent_count = 0;
			int empty_count = 0;
			
			/* Count pieces in this window */
			for (int i = 0; i < 4; i++) {
				if (board[r][c + i] == player) player_count++;
				else if (board[r][c + i] == opponent) opponent_count++;
				else empty_count++;
			}
			
			/* Score this window based on pattern */
			if (player_count == 4) score += 100;        /* Win */
			else if (player_count == 3 && empty_count == 1) score += 5;  /* Strong threat */
			else if (player_count == 2 && empty_count == 2) score += 2;  /* Weak threat */
			
			if (opponent_count == 4) score -= 100;      /* Opponent win */
			else if (opponent_count == 3 && empty_count == 1) score -= 4; /* Must block */
		}
	}
	
	/* Vertical windows */
	for (int c = 0; c < COLS; c++) {
		for (int r = 0; r <= ROWS - 4; r++) {
			int player_count = 0;
			int opponent_count = 0;
			int empty_count = 0;
			
			for (int i = 0; i < 4; i++) {
				if (board[r + i][c] == player) player_count++;
				else if (board[r + i][c] == opponent) opponent_count++;
				else empty_count++;
			}
			
			if (player_count == 4) score += 100;
			else if (player_count == 3 && empty_count == 1) score += 5;
			else if (player_count == 2 && empty_count == 2) score += 2;
			
			if (opponent_count == 4) score -= 100;
			else if (opponent_count == 3 && empty_count == 1) score -= 4;
		}
	}
	
	/* Positive slope diagonal windows (/) */
	for (int r = 0; r <= ROWS - 4; r++) {
		for (int c = 0; c <= COLS - 4; c++) {
			int player_count = 0;
			int opponent_count = 0;
			int empty_count = 0;
			
			for (int i = 0; i < 4; i++) {
				if (board[r + i][c + i] == player) player_count++;
				else if (board[r + i][c + i] == opponent) opponent_count++;
				else empty_count++;
			}
			
			if (player_count == 4) score += 100;
			else if (player_count == 3 && empty_count == 1) score += 5;
			else if (player_count == 2 && empty_count == 2) score += 2;
			
			if (opponent_count == 4) score -= 100;
			else if (opponent_count == 3 && empty_count == 1) score -= 4;
		}
	}
	
	/* Negative slope diagonal windows (\) */
	for (int r = 3; r < ROWS; r++) {
		for (int c = 0; c <= COLS - 4; c++) {
			int player_count = 0;
			int opponent_count = 0;
			int empty_count = 0;
			
			for (int i = 0; i < 4; i++) {
				if (board[r - i][c + i] == player) player_count++;
				else if (board[r - i][c + i] == opponent) opponent_count++;
				else empty_count++;
			}
			
			if (player_count == 4) score += 100;
			else if (player_count == 3 && empty_count == 1) score += 5;
			else if (player_count == 2 && empty_count == 2) score += 2;
			
			if (opponent_count == 4) score -= 100;
			else if (opponent_count == 3 && empty_count == 1) score -= 4;
		}
	}
	
	/* Bonus for center column control (more opportunities) */
	for (int r = 0; r < ROWS; r++) {
		if (board[r][3] == player) score += 3;
	}
	
	return score;
}

/**
 * Check if the game is over (win or draw)
 * 
 * Returns: 1 if game over, 0 if game continues
 */
int is_game_over(void) {
	/* Check for any winning position */
	for (int r = 0; r < ROWS; r++) {
		for (int c = 0; c < COLS; c++) {
			if (board[r][c] != cell_empty) {
				GameMove test = {r, c};
				if (check_winner(test, board[r][c])) {
					return 1;
				}
			}
		}
	}
	
	/* Check for draw (top row full) */
	int full = 1;
	for (int c = 0; c < COLS; c++) {
		if (board[0][c] == cell_empty) {
			full = 0;
			break;
		}
	}
	
	return full;
}

/**
 * Get all valid moves (columns that aren't full)
 * 
 * Parameters:
 *   valid_cols - Array to fill with valid column numbers
 *   count      - Output: number of valid columns
 */
void get_valid_moves(int* valid_cols, int* count) {
	*count = 0;
	for (int c = 0; c < COLS; c++) {
		if (board[0][c] == cell_empty) {
			valid_cols[*count] = c;
			(*count)++;
		}
	}
}

/**
 * Make a move on the board (for minimax simulation)
 * 
 * Returns: Row where piece was placed, -1 if column full
 */
int make_move(int col, Cell player) {
	for (int r = ROWS - 1; r >= 0; r--) {
		if (board[r][col] == cell_empty) {
			board[r][col] = player;
			return r;
		}
	}
	return -1;
}

/**
 * Undo a move (for minimax simulation)
 */
void undo_move(int row, int col) {
	board[row][col] = cell_empty;
}

/**
 * Minimax algorithm with alpha-beta pruning
 * Recursively evaluates all possible game states to find optimal move
 * 
 * Parameters:
 *   depth      - Remaining search depth
 *   alpha      - Best value for maximizer (pruning parameter)
 *   beta       - Best value for minimizer (pruning parameter)
 *   maximizing - 1 if maximizing player's turn, 0 if minimizing
 *   player     - The AI player (maximizer)
 * 
 * Returns: Evaluated score for this position
 */
int minimax(int depth, int alpha, int beta, int maximizing, Cell player) {
	Cell opponent = (player == cell_player1) ? cell_player2 : cell_player1;
	
	/* Terminal conditions: depth limit or game over */
	if (depth == 0 || is_game_over()) {
		return evaluate_position(player);
	}
	
	/* Get available moves */
	int valid_cols[COLS];
	int move_count;
	get_valid_moves(valid_cols, &move_count);
	
	if (move_count == 0) {
		return 0; /* Draw */
	}
	
	if (maximizing) {
		/* Maximizing player (AI) - wants highest score */
		int max_eval = INT_MIN;
		for (int i = 0; i < move_count; i++) {
			int col = valid_cols[i];
			int row = make_move(col, player);
			
			int eval = minimax(depth - 1, alpha, beta, 0, player);
			
			undo_move(row, col);
			
			max_eval = (eval > max_eval) ? eval : max_eval;
			alpha = (alpha > eval) ? alpha : eval;
			
			if (beta <= alpha) {
				break; /* Beta cutoff - prune remaining branches */
			}
		}
		return max_eval;
	} else {
		/* Minimizing player (opponent) - wants lowest score */
		int min_eval = INT_MAX;
		for (int i = 0; i < move_count; i++) {
			int col = valid_cols[i];
			int row = make_move(col, opponent);
			
			int eval = minimax(depth - 1, alpha, beta, 1, player);
			
			undo_move(row, col);
			
			min_eval = (eval < min_eval) ? eval : min_eval;
			beta = (beta < eval) ? beta : eval;
			
			if (beta <= alpha) {
				break; /* Alpha cutoff - prune remaining branches */
			}
		}
		return min_eval;
	}
}

/**
 * AI Hard difficulty - Minimax with alpha-beta pruning
 * Looks ahead 5 moves to find optimal play
 * Most challenging AI - plays near-perfectly
 * 
 * Returns: Optimal move
 */
GameMove ai_hard_move(void) {
	const int SEARCH_DEPTH = 5; /* Look ahead 5 moves */
	
	/* Always take immediate win if available */
	GameMove winning_move = find_winning_move(cell_player2);
	if (winning_move.row != -1) {
		return winning_move;
	}
	
	/* Always block opponent's immediate win */
	GameMove blocking_move = find_winning_move(cell_player1);
	if (blocking_move.row != -1) {
		return blocking_move;
	}
	
	/* Use minimax to find optimal move */
	int valid_cols[COLS];
	int move_count;
	get_valid_moves(valid_cols, &move_count);
	
	int best_score = INT_MIN;
	int best_col = 3; /* Default to center if all else fails */
	
	/* Evaluate each possible move */
	for (int i = 0; i < move_count; i++) {
		int col = valid_cols[i];
		int row = make_move(col, cell_player2);
		
		/* Recursively evaluate this move */
		int score = minimax(SEARCH_DEPTH - 1, INT_MIN, INT_MAX, 0, cell_player2);
		
		undo_move(row, col);
		
		/* Track best move */
		if (score > best_score) {
			best_score = score;
			best_col = col;
		}
	}
	
	/* Execute the best move found */
	for (int r = ROWS - 1; r >= 0; r--) {
		if (board[r][best_col] == cell_empty) {
			GameMove move = {r, best_col};
			return move;
		}
	}
	
	/* Fallback (should never reach here) */
	return ai_easy_move();
}

