#include "ai.h"
#include "board.h"
#include "input.h"
#include "game.h"
#include <stdlib.h>
#include <time.h>

GameMove find_winning_move(Cell player) {
	// Try each column
	for (int col = 0; col < COLS; col++) {
		// Find the lowest empty row in this column
		for (int row = ROWS - 1; row >= 0; row--) {
			if (board[row][col] == cell_empty) {
				// Simulate placing the piece
				board[row][col] = player;
				GameMove test_move = { row, col };

				// Check if this move wins
				if (check_winner(test_move, player) == 1) {
					// Undo the simulated move
					board[row][col] = cell_empty;
					// Return this winning move
					return test_move;
				}

				// Undo the simulated move
				board[row][col] = cell_empty;
				break; // Only check the lowest empty position in this column
			}
		}
	}

	// No winning move found - return invalid move
	GameMove no_move = { -1, -1 };
	return no_move;
}

// Count threats (2 or 3 in a row) for a given move
int count_threats(int row, int col, Cell player) {
	int threats = 0;
	
	// Simulate the move
	board[row][col] = player;
	GameMove test_move = {row, col};
	
	// Check all directions for potential connects
	// Horizontal
	int count = 1;
	int temp_col = col;
	while (temp_col + 1 < COLS && board[row][temp_col + 1] == player) {
		count++;
		temp_col++;
	}
	temp_col = col;
	while (temp_col - 1 >= 0 && board[row][temp_col - 1] == player) {
		count++;
		temp_col--;
	}
	if (count >= 2) threats += count;
	
	// Vertical
	count = 1;
	int temp_row = row;
	while (temp_row + 1 < ROWS && board[temp_row + 1][col] == player) {
		count++;
		temp_row++;
	}
	temp_row = row;
	while (temp_row - 1 >= 0 && board[temp_row - 1][col] == player) {
		count++;
		temp_row--;
	}
	if (count >= 2) threats += count;
	
	// Undo the move
	board[row][col] = cell_empty;
	
	return threats;
}

// Find the best strategic move
GameMove find_best_strategic_move(Cell player) {
	int best_score = -1;
	GameMove best_move = {-1, -1};
	
	// Evaluate each column
	for (int col = 0; col < COLS; col++) {
		for (int row = ROWS - 1; row >= 0; row--) {
			if (board[row][col] == cell_empty) {
				int score = count_threats(row, col, player);
				
				// Bonus for center columns
				if (col == 3) score += 3;
				else if (col == 2 || col == 4) score += 2;
				else if (col == 1 || col == 5) score += 1;
				
				if (score > best_score) {
					best_score = score;
					best_move.row = row;
					best_move.column = col;
				}
				break; // Only check lowest position
			}
		}
	}
	
	return best_move;
}

GameMove ai_easy_move() {
	int column = rand() % 7;
	//check if column is full
	int i;
	int full = 1;
	int row;
	for (i = 5; i >= 0; i--) {
		if (board[i][column] == cell_empty) {
			full = 0;
			row = i;
			break;
		}
	}
	if (full) {
		//printf("Collumn full, input another collumn\n");
		return ai_easy_move();
	}
	else {
		GameMove move = { row,column };
		return move;
	}
}

GameMove ai_medium_move() {
	// Initialize random seed once
	static int seeded = 0;
	if (!seeded) {
		srand((unsigned int)time(NULL));
		seeded = 1;
	}
	
	// 1. Check if AI can win
	GameMove winning_move = find_winning_move(cell_player2);
	if (winning_move.row != -1) {
		return winning_move;
	}

	// 2. Block player from winning
	GameMove blocking_move = find_winning_move(cell_player1);
	if (blocking_move.row != -1) {
		return blocking_move;
	}

	// 3. Find best strategic move (builds threats and prefers center)
	GameMove strategic_move = find_best_strategic_move(cell_player2);
	if (strategic_move.row != -1) {
		// Add 30% randomness - sometimes don't take the best move
		if (rand() % 100 < 70) {
			return strategic_move;
		}
	}

	// 4. Random center-biased move (30% of the time or if no good move found)
	int center_preference[] = {3, 2, 4, 1, 5, 0, 6};
	
	// Shuffle the center preference array for variety
	for (int i = 0; i < 7; i++) {
		int j = rand() % 7;
		int temp = center_preference[i];
		center_preference[i] = center_preference[j];
		center_preference[j] = temp;
	}
	
	for (int i = 0; i < 7; i++) {
		int col = center_preference[i];
		for (int row = ROWS - 1; row >= 0; row--) {
			if (board[row][col] == cell_empty) {
				GameMove move = { row, col };
				return move;
			}
		}
	}

	// 5. Fallback to random (shouldn't happen unless board is full)
	return ai_easy_move();
}

